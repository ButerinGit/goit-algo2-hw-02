# goit-algo2-hw-02

Домашнє завдання містить два алгоритмічні завдання:

1. **Пошук мінімального та максимального елементів** методом «розділяй і володарюй».
2. **Оптимізація черги 3D-друку** з урахуванням пріоритетів і обмежень принтера (жадібний алгоритм).

Проєкт не потребує зовнішніх бібліотек — використовується лише стандартна бібліотека Python.

---

## Структура проєкту

```
goit-algo2-hw-02/
│
├─ task1_find_min_max/
│   └─ find_min_max.py
│
├─ task2_test_printing_optimization/
│   └─ test_printing_optimization.py
│
├─ .gitignore
├── README.md
└─ requirements.txt
```

---

## Вимоги

- Python **3.7+** (у мене використовується Python 3.14.0)
- Зовнішні пакети не потрібні.

---

# Завдання 1 — Find Min/Max (Divide and Conquer)

### Опис
Реалізовано рекурсивний алгоритм пошуку мінімального та максимального елементів у масиві за підходом «розділяй і володарюй».

### Ідея алгоритму
1. Масив рекурсивно ділиться на дві частини.
2. Для кожної половини знаходяться `(min, max)`.
3. Результати поєднуються:  
   `global_min = min(min_left, min_right)`  
   `global_max = max(max_left, max_right)`

### Складність
- Часова: **O(n)**
- Пам’ять (через рекурсію): **O(log n)**

### Запуск
Перейти в папку завдання:

```bash
cd task1_find_min_max
python3 find_min_max.py
```

### Очікуваний приклад виводу
(при вбудованому тесті в кінці файлу)

```
Перевірка find_min_max:
масив: [3, 1, 7, -2, 5]
мін: -2 макс: 7
```

---

# Завдання 2 — 3D Printing Queue Optimization (Greedy)

### Опис
Розроблено програму оптимізації черги 3D-друку:

- завдання з більшим пріоритетом виконуються раніше;
- моделі групуються для одночасного друку;
- враховуються обмеження за об’ємом і кількістю моделей;
- час друку групи = **максимальний print_time серед моделей групи**.

### Формат вхідних даних

```python
print_jobs = [
    {"id": "M1", "volume": 100, "priority": 1, "print_time": 120},
    ...
]

constraints = {
    "max_volume": 300,
    "max_items": 2
}
```

### Ідея алгоритму
1. Сортуємо завдання стабільно за пріоритетом (1 → 2 → 3).
2. Жадібно формуємо групи:
   - додаємо модель у поточну групу, якщо не перевищуємо ліміти;
   - якщо перевищуємо — закриваємо групу та починаємо нову.
3. Підраховуємо сумарний час.

### Складність
- Сортування: **O(n log n)**
- Формування груп: **O(n)**
- Загалом: **O(n log n)** (домінує сортування)

### Запуск тестів

```bash
cd task2_test_printing_optimization
python3 test_printing_optimization.py
```

### Очікуваний результат

```
Тест 1 (однаковий пріоритет):
Порядок друку: ['M1', 'M2', 'M3']
Загальний час: 270 хвилин

Тест 2 (різні пріоритети):
Порядок друку: ['M2', 'M1', 'M3']
Загальний час: 270 хвилин

Тест 3 (перевищення обмежень):
Порядок друку: ['M1', 'M2', 'M3']
Загальний час: 450 хвилин
```

---

## Автор
Валентин І.  
Neoversity / GoIT Algo 2
